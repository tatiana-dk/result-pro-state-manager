# AtomFlow

Минималистичный стейт-менеджер с атомарной реактивностью.

## Почему эта модель имеет смысл?
В ванильном JavaScript управление состоянием быстро становится хаосом: данные разбросаны, обновления интерфейса ручные, трудно отслеживать изменения.

## Какие боли она решает?

- Сложность синхронизации — когда данные в разных компонентах расходятся
- Ручное обновление UI — приходится вручную перерисовывать элементы
- Проблемы масштабирования — код превращается в «спагетти» при росте приложения
- Отладка — сложно понять, где и почему изменилось состояние

AtomFlow предлагает простую модель: разбей состояние на независимые части (атомы), подпишись на изменения — интерфейс обновится сам.

## Принцип работы

Представь, что состояние приложения — это набор ящичков (атомов). В каждом ящичке лежат данные. Можно подписаться на изменения любого ящичка: когда в нём что-то меняется, ты сразу получаешь уведомление. Есть главный склад (хранилище), где регистрируются все ящички. Можно создавать специальные ящички, которые автоматически пересчитывают своё содержимое на основе других. Всё это работает без магии — просто подписки и вызовы функций.

## Что умеет библиотека

- Создавать единое хранилище для всего состояния
- Разбивать состояние на независимые атомы (ключ + значение)
- Автоматически уведомлять подписчиков при изменении атома
- Создавать вычисляемые значения на основе других атомов
- Работать в чистом JavaScript без зависимостей

## Примеры использования

Создание хранилища и атомов:

```javascript
import { createStore } from './atomflow.js';

const store = createStore();
const userAtom = store.createAtom('user', { name: 'Анна' });
const counterAtom = store.createAtom('counter', 0);
```

Чтение и запись:

```javascript
console.log(counterAtom.get()); // 0
counterAtom.set(5); // Новое значение
```

Подписка на изменения:

```javascript
const unsubscribe = counterAtom.subscribe(value => {
    console.log(`Счётчик изменился: ${value}`);
    document.getElementById('counter').textContent = value;
});

// Позже...
unsubscribe(); // Перестаём слушать
```

Вычисляемые значения:

```javascript
const price = store.createAtom('price', 100);
const quantity = store.createAtom('quantity', 2);

const total = store.createComputedAtom('total', 
    [price, quantity], 
    (p, q) => p * q
);

console.log(total.get()); // 200
```

## Архитектура

- Атомарность — каждая часть состояния независима, легко тестировать и переиспользовать
- Реактивность — минимум кода для максимального эффекта
- Простота — маленький API, который можно освоить за 10 минут
- Гибкость — можно использовать фрагментарно, не переписывая всё приложение

## Принципы:

- Одна ответственность — атом отвечает только за свои данные
- Прозрачность — никакой скрытой магии, всё на подписках
- Минимализм — меньше кода, меньше ошибок
- Прагматизм — решает реальные проблемы, а не добавляет абстракции

## Как использовать в ToDo-приложении

```javascript
// 1. Создаём атом для задач
const tasksAtom = store.createAtom('tasks', []);

// 2. Функции для обновления
function addTask(text) {
    tasksAtom.set([...tasksAtom.get(), { text, done: false }]);
}

// 3. Подписываем рендер-функцию
tasksAtom.subscribe(tasks => renderTaskList(tasks));

// 4. Интерфейс автоматически обновляется
```

## Планы на будущее

- DevTools расширение для визуализации атомов и их зависимостей
- Time-travel debugging — возможность откатывать изменения состояния
- Серверная синхронизация — готовые адаптеры для REST/WebSocket
- Оптимизация производительности — батчинг обновлений, мемоизация
- Плагины — middleware для логирования, валидации, persistence
- TypeScript поддержка — полная типизация из коробки

AtomFlow — не пытается быть всем для всех. Это острый инструмент для конкретной задачи: сделать управление состоянием в JavaScript простым и предсказуемым. Попробуй в своём следующем проекте!